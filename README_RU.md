<p align="center">
  <a href="https://github.com/momentics/NanoVNA-X/actions/workflows/firmware.yml"><img src="https://github.com/momentics/NanoVNA-X/actions/workflows/firmware.yml/badge.svg?branch=main" alt="Состояние непрерывной интеграции прошивки"></a>
  <a href="https://github.com/momentics/NanoVNA-X/actions/workflows/release-artifacts.yml"><img src="https://github.com/momentics/NanoVNA-X/actions/workflows/release-artifacts.yml/badge.svg" alt="Состояние сборки релизных артефактов"></a>
</p>

NanoVNA-X - усовершенствованная прошивка для карманных векторных анализаторов NanoVNA -H/H4, более стабильные измерения, улучшенный интерфейс
===============================================================================
[English version](README.md)

<div align="center">
<img src="/doc/NanoVNA.jpg" width="280px">
</div>

# О проекте

**NanoVNA-H** и **NanoVNA-H4** — это очень компактные переносные приборы класса Vector Network Analyzer (VNA — векторный анализатор цепей).
Они представляют собой автономные портативные устройства с дисплеем Liquid Crystal Display (LCD — жидкокристаллический индикатор) и аккумулятором.

Поддержкой NanoVNA-X занимается **@momentics** (https://github.com/momentics/), проект оптимизирован под платформы STM32F072 и STM32F303 с ограниченными ресурсами памяти.
Кодовая база развивает выдающуюся работу [@DiSlord](https://github.com/DiSlord/) и восходит к исходной прошивке, созданной [@edy555](https://github.com/edy555).
Прошивка продолжает распространяться на условиях лицензии GNU General Public License (GNU GPL), что позволяет первоначальным авторам сохранять права на свои разработки.

Этот репозиторий содержит исходные тексты улучшенной прошивки NanoVNA-H и NanoVNA-H4, используемой в проекте NanoVNA-X.
Документация описывает процесс сборки и прошивки в среде macOS или Linux (Debian либо Ubuntu); другие дистрибутивы Linux (а также BSD) обычно ведут себя аналогично.

## Улучшения​
В прошивку добавлен асинхронный event bus с лёгкой схемой publish/subscribe, который развязывает модули измерительного конвейера, UI и подсистемы конфигурации; это снизило связность, упростило добавление функций и позволило безопасно ретранслировать события свипа, изменения настроек и системные сигналы без блокировок долгоживущих задач.​
Над планировщиком реализован кооперативный scheduler с привязкой воркеров к приоритетам измерений и отрисовки, что устраняет «дрожание» интерфейса под нагрузкой и обеспечивает предсказуемые окна выполнения DSP и I/O; вместе с этим пересмотрены хуки и тайм‑кванты, чтобы исключить взаимные задержки при обмене с синтезатором и аудио‑кодеком.

### Стабилизация переходных процессов PLL​
Стабилизация переходных процессов PLL выполнена за счёт оптимизации последовательности программирования частотного синтезатора и предрасчёта параметров захвата: введены поэтапные задержки, контроль статуса lock и кэширование опорных частот для сокращения перенастройки; в результате уменьшены выбросы и дрейф в начале свипа и при быстрых перестройках.​
Дополнительно скорректированы параметры фильтра петли и порядок включения выходов, что снижает амплитуду переходных и ускоряет установление стабильной фазы на рабочих поддиапазонах; это повысило повторяемость измерений и уменьшило потребность в дополнительном сглаживании в DSP.

## Обзор архитектуры

NanoVNA-X использует многослойную архитектуру, разделяющую этапы загрузки, аппаратную интеграцию, обработку измерений и пользовательский интерфейс. Такой подход позволяет поддерживать сопровождаемость и вписываться в строгие ограничения по объему флэш-памяти и оперативной памяти на микроконтроллерах STM32F072 и STM32F303.

* **Загрузка и выполнение приложения.** Прошивка стартует в `src/core/main.c`, где управление передается функции `app_main()`. Вся логика верхнего уровня сосредоточена в `src/app/application.c`: здесь инициализируется ChibiOS/RT, настраиваются USB-консоль и драйверы синтезатора, поднимается измерительный конвейер и запускается выделенный поток опроса, координирующий измерения, обновление интерфейса и обработку команд консоли.
* **Аппаратная абстракция.** Модуль `src/platform/platform_hal.c` обращается к таблице драйверов, зарегистрированной в `src/platform/boards/`, чтобы каждая поддерживаемая плата предоставляла структуру `PlatformDrivers` с инициализацией и описаниями периферии. Это изолирует ядро приложения от различий между NanoVNA-H (STM32F072) и NanoVNA-H4 (STM32F303).
* **Слой сервисов.** Общая инфраструктура расположена в каталоге `src/services/`. Шина событий реализует легкий механизм публикации/подписки и рассылает уведомления о старте и завершении измерительных проходов, изменении конфигурации и других состояниях. Планировщик предоставляет обертку над потоками ChibiOS, а сервис конфигурации отвечает за сохранение настроек пользователя и слотов калибровки во флэш-памяти с контролем целостности.
* **Измерительный конвейер и DSP.** Файл `src/measurement/pipeline.c` выступает фасадом между платформенными драйверами и измерительными процедурами в `src/app/application.c`. Он отслеживает активные каналы, выполняет циклы опроса и дает точки расширения для сглаживания или преобразования домена. Численные помощники и математические алгоритмы калибровки вынесены в `src/dsp/`, чтобы изолировать ресурсоемкий код от прямого доступа к оборудованию.
* **Драйверы и middleware.** Низкоуровневые взаимодействия с железом реализованы в `src/drivers/` — здесь находятся драйверы дисплея, синтезатора Si5351, кодека TLV320 и USB-интерфейса. Каталог `src/middleware/` содержит небольшие интеграционные прослойки, например привязку `chprintf` к потокам ChibiOS. Сторонние компоненты (ChibiOS, FatFs) добавлены в `third_party/` и конфигурируются через заголовки в `config/` и файлы верхнего уровня `chconf.h`/`halconf.h`.
* **Пользовательский интерфейс.** Поток опроса инициализирует инструментарий UI (`src/ui/`), обрабатывает аппаратный ввод, обновляет графики и отмечает области экрана для перерисовки. Шрифты и пиктограммы, используемые отрисовкой, хранятся в `src/resources/`. Дополнительные функциональные блоки — например встроенный браузер в `src/modules/` — могут подписываться на события или запускать задачи, не вмешиваясь в основной цикл.

Публичные заголовки вынесены в `include/`, а поддержка плат, скрипты компоновки и стартовый код находятся в каталоге `boards/`. Такая структура позволяет использовать единые механизмы измерений и пользовательского интерфейса на обеих аппаратных платформах, ограничиваясь лишь точечными переопределениями.

## Аппаратная платформа и используемые чипы
Основные целевые MCU — STM32F072xB и STM32F303 (NanoVNA-H/H4); плата F072 использует 8 МГц кварц, линии USB, SPI, I²C, I²S для дисплея, SD, кодека и сенсора, как описано в board.h.

Тактовый генератор Si5351A (или совместимый) управляет выходными синтезаторами, а также формирует опорные частоты для аудио АЦП; драйвер реализует кэширование частот, управление мощностью и инициализацию PLL по I²C.

TLV320AIC3204 служит двухканальным аудио АЦП/ЦАП (I²S), с конфигурацией PLL и маршрутизацией входов; прошивка управляет им через I²C и выводит рабочий поток по SPI/I²S.

Дисплейные контроллеры ILI9341/ST7789 (320×240) и ST7796S (480×320) выбираются по плате; поддерживается DMA, регулировка яркости (для H4), инверсия и тени текста для повышения читаемости.

Дополнительные функции включают RTC, SD-карту (скриншоты, прошивка, файловый менеджер), USB UID, дистанционное управление, модуль измерений (LC matching, анализ кабеля и резонансов).

## Сборка прошивки

NanoVNA-X использует стандартный процесс на основе GNU Make и компилятора Arm GNU GCC.
Полное руководство приведено в файле [`doc/building.md`](doc/building.md), а ниже приведено краткое резюме шагов для чистой сборки.

### 1. Установите кросс-компилятор

Поддерживаются актуальные версии пакета `gcc-arm-none-eabi`; нет необходимости полагаться на архивные сборки.

#### macOS (Homebrew)

```
brew install gcc-arm-none-eabi dfu-util
```

#### Ubuntu / Debian

```
sudo apt update
sudo apt install gcc-arm-none-eabi libnewlib-arm-none-eabi dfu-util
```

После установки проверьте доступность компилятора:

```
arm-none-eabi-gcc --version
```

### 2. Получите исходный код

Клонируйте репозиторий и убедитесь, что сторонние зависимости инициализированы:

```
git clone https://github.com/momentics/NanoVNA-X.git
cd NanoVNA-X
git submodule update --init --recursive
```

Для последующего обновления до свежей ревизии достаточно выполнить `git pull`.

### 3. Соберите нужный профиль прошивки

Установите переменную окружения `TARGET`, чтобы выбрать плату, и запустите `make`.
При переключении между целями используйте `make clean`, чтобы избежать смешения артефактов.

```
export TARGET=F072   # NanoVNA-H (значение по умолчанию)
make clean
make -j$(nproc)
```

Для сборки прошивки NanoVNA-H4 задайте `TARGET=F303`.
Результаты компиляции записываются в каталог `build/` (`H.bin`/`H4.bin`, `.elf`, `.hex`).
См. файл [doc/building.md](doc/building.md) с пояснением, какой артефакт выбрать для прошивки по Device Firmware Upgrade (DFU — обновление встроенного программного обеспечения через USB), интерфейсу Serial Wire Debug (SWD — последовательный отладочный интерфейс) либо для отладчика.

### 4. Прошейте устройство

Переведите прибор в режим Device Firmware Upgrade (DFU) одним из способов:

* Откройте прибор и при подаче питания замкните контакт `BOOT0` на питание `Vdd`.
* Выберите в меню пункт Config → DFU (требуется актуальная прошивка).
* Нажмите энкодер NanoVNA-H4 при подаче питания.

Затем прошейте двоичный файл, созданный на предыдущем шаге:

```
export TARGET=F072
make flash
```

Цель `make flash` использует утилиту Device Firmware Upgrade Utility (`dfu-util`) и загружает соответствующий артефакт `build/H.bin` либо `build/H4.bin` для выбранной платы.
`dfu-util` выводит диагностические сообщения, например кратковременное предупреждение о «поврежденной прошивке» при выходе устройства из режима DFU; скрипт сборки автоматически очищает статус, и это сообщение можно игнорировать.

## Сопутствующие инструменты

Существует несколько качественных программных инструментов для персонального компьютера Personal Computer (PC), созданных сторонними разработчиками.

* [GoVNA](https://github.com/momentics/GoVNA): Надёжная и безопасная библиотека Go для управления векторными анализаторами цепей NanoVNA. Поддерживаются несколько протоколов (V1, V2/LiteVNA), автоматическое определение устройств и оптимизирована для высокопроизводительных серверных приложений.
* [PyVNA](https://github.com/momentics/PyVNA): Многопротокольная библиотека Python для NanoVNA V1/V2/LiteVNA, созданная на основе GoVNA для высокопроизводительных и безопасных серверных приложений. Поддерживает автоматическое определение, надёжное объединение устройств в пул и комплексную обработку данных.
* [NanoVNA-App software](https://github.com/OneOfEleven/NanoVNA-H/blob/master/Release/NanoVNA-App.rar) от OneOfEleven

## Документация

* [NanoVNA User Guide (ja)](https://cho45.github.io/NanoVNA-manual/) от cho45. [(en: google translate)](https://translate.google.com/translate?sl=ja&tl=en&u=https%3A%2F%2Fcho45.github.io%2FNanoVNA-manual%2F)
* [Группа пользователей NanoVNA](https://groups.io/g/nanovna-users/topics) на портале groups.io.

## Справочные материалы

* [Схемотехника](/doc/nanovna-sch.pdf)
* [Фотография печатной платы](/doc/nanovna-pcb-photo.jpg)
* [Структурная схема](/doc/nanovna-blockdiagram.png)

## Примечание

Материалы по аппаратной части опубликованы, чтобы предотвратить появление некачественных копий.
Если у вас есть собственный экземпляр, пожалуйста, сообщите об этом.

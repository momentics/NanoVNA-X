<p align="center">
  <a href="https://github.com/momentics/NanoVNA-X/actions/workflows/firmware.yml"><img src="https://github.com/momentics/NanoVNA-X/actions/workflows/firmware.yml/badge.svg?branch=main" alt="Состояние непрерывной интеграции прошивки"></a>
  <a href="https://github.com/momentics/NanoVNA-X/actions/workflows/release-artifacts.yml"><img src="https://github.com/momentics/NanoVNA-X/actions/workflows/release-artifacts.yml/badge.svg" alt="Состояние сборки релизных артефактов"></a>
</p>

NanoVNA-X - усовершенствованная прошивка для карманных векторных анализаторов NanoVNA -H/H4
===============================================================================
[English version](README.md)
[![Release](https://img.shields.io/github/v/release/momentics/NanoVNA-X)](https://github.com/momentics/NanoVNA-X/releases)
[![Maintenance](https://img.shields.io/maintenance/yes/2025)]()

<div align="center">
<img src="/doc/NanoVNA.jpg" width="280px">
</div>

# О проекте

**NanoVNA-H** и **NanoVNA-H4** — это очень компактные переносные приборы класса Vector Network Analyzer (VNA — векторный анализатор цепей).
Они представляют собой автономные портативные устройства с дисплеем Liquid Crystal Display (LCD — жидкокристаллический индикатор) и аккумулятором.

Поддержкой NanoVNA-X занимается **@momentics** (https://github.com/momentics/), проект оптимизирован под платформы STM32F072 и STM32F303 с ограниченными ресурсами памяти.
Кодовая база развивает выдающуюся работу [@DiSlord](https://github.com/DiSlord/) и восходит к исходной прошивке, созданной [@edy555](https://github.com/edy555).
Прошивка продолжает распространяться на условиях лицензии GNU General Public License (GNU GPL), что позволяет первоначальным авторам сохранять права на свои разработки.

Этот репозиторий содержит исходные тексты улучшенной прошивки NanoVNA-H и NanoVNA-H4, используемой в проекте NanoVNA-X.
Документация описывает процесс сборки и прошивки в среде macOS или Linux (Debian либо Ubuntu); другие дистрибутивы Linux (а также BSD) обычно ведут себя аналогично.

## Благодарности и дисклеймер

- Выражаются глубокие благодарности [@DiSlord](https://github.com/DiSlord/) за исходный текст прошивки и основы, которые существенно вдохновили и позволили начать работу над этим новым проектом прошивки.
- Проект стремительно развивается и с каждым днём всё больше отходит от исходной реализации.
- Исходная кодовая база была чрезвычайно насыщена функциями; чтобы сделать дальнейшую разработку возможной, подсистема SD временно удалена для снижения сложности и разблокирования ключевой переработки архитектуры. Подсистема SD вернётся, когда основные функции будут реализованы в задуманном виде и архитектура станет готовой для её корректной поддержки.

## Чем NanoVNA-X отличается от других прошивок

- **Предсказуемая событийная архитектура.** Движок свипа, UI, USB CDC-оболочка и DSP взаимодействуют через шину событий ChibiOS и сторожевые тайм-ауты. Зависший кодек, синтезатор или ПК-хост больше не могут «подвесить» прибор во время калибровки.
- **DMA зарезервирован под измерения.** Передачи SPI LCD и приём данных TLV320 по I²S выполняются через DMA, а UART-консоль сознательно переведена на драйвер прерываний, чтобы каналы DMA всегда были доступны критичным трактам измерений.
- **Уникальный USB-серийный номер по умолчанию.** Каждое устройство теперь объявляется с номером, вычисленным по уникальному идентификатору микроконтроллера (при необходимости его всё ещё можно отключить в System -> Device -> MORE -> *USB DEVICE UID*).

## Улучшения
Начиная с версии [@DiSlord](https://github.com/DiSlord/), прошивка претерпела значительную переработку архитектуры и стабилизацию. Основное внимание было уделено отзывчивости, удобству автономного использования и производительности на устройствах с ограниченным объемом памяти.

### Стабильность и отзывчивость прошивки
Ядро прошивки было переработано: вместо блокирующих вызовов теперь используется полностью асинхронная, событийно-ориентированная архитектура на основе примитивов ChibiOS (почтовые ящики, события и семафоры).
*   **Неблокирующий USB:** Стек USB CDC (виртуальный COM-порт) теперь полностью асинхронен. Прошивка больше не зависает, если хост-компьютер подключается, отключается или "тормозит" во время передачи данных. Это решает самую частую причину зависаний прибора.
*   **Восстановление по таймаутам:** Критически важные подсистемы, включая измерительный движок и шину I²C, защищены таймаутами. "Зависшая" операция больше не блокирует все устройство; вместо этого подсистема пытается корректно восстановить свою работу.
*   **Параллелизм на основе RTOS:** Циклы ожидания (busy-wait) и постоянные опросы были заменены на эффективные сигнальные механизмы RTOS, что снижает нагрузку на процессор и увеличивает время работы от батареи. Измерительный поток, пользовательский интерфейс и стек USB теперь работают согласованно, без гонок состояний и взаимоблокировок.
*   **Сохранение состояния:** Выделенный модуль `system/state_manager` отслеживает лимиты свипа, флаги UI и активный слот калибровки: изменения автоматически сбрасываются во flash после паузы редактирования (или мгновенно через пункт меню *SAVE CONFIG*), поэтому корректировки диапазонов переживают выключение без лишних циклов записи.
*   **Синхронизация UI и измерений:** Пользовательский интерфейс и измерительный движок теперь разделены. Интерфейс остается отзывчивым даже во время сложных вычислений, а данные на экране всегда синхронизированы с состоянием измерений.

### Производительность и управление ресурсами
*   **Целевая оптимизация памяти:** Потребление статической ОЗУ было значительно сокращено, особенно для STM32F072 (NanoVNA-H) с 16 КБ памяти. Это было достигнуто путем настройки размеров буферов, отключения таких функций, как кэширование трасс на моделях с малым объемом памяти, и перемещения ключевых буферов в CCM RAM на STM32F303.
*   **Стратегическое использование DMA:** Архитектура DMA была доработана для повышения стабильности измерений. DMA используется для самых требовательных путей данных:
    *   **Интерфейс дисплея (SPI):** Обеспечивает плавную и быструю отрисовку интерфейса и графиков.
    *   **Измерительный конвейер (I²S):** Гарантирует доставку сэмплов от кодека без потерь.
    *   Чтобы освободить каналы DMA для этих критических задач, **консоль UART была намеренно переведена на драйвер, работающий на прерываниях (без DMA).** Это предотвращает конфликты ресурсов и ставит в приоритет целостность измерений.

### Новые функции и возможности
*   **Стабилизация PLL:** Последовательность программирования синтезатора Si5351 была оптимизирована для уменьшения выбросов и дрейфа частоты, что повышает повторяемость измерений, особенно в начале сканирования.
*   **Детерминированный USB-нумератор:** Режим USB DEVICE UID теперь включён по умолчанию, поэтому каждое устройство сразу объявляется с устойчивым серийным номером, распознаваемым NanoVNA-App, NanoVNA Saver и другими утилитами.

### Процесс сборки и разработки
*   **Автоматическое версионирование:** Версия прошивки теперь автоматически встраивается в процессе сборки из единого файла `VERSION`.
*   **Улучшенный CI/CD:** Рабочие процессы GitHub Actions были оптимизированы для более быстрых и надежных сборок с улучшенным кэшированием.
*   **Генерация DFU-файлов:** В процесс выпуска релизов интегрирован скрипт на Python для создания файлов прошивки, совместимых с DfuSe.

## Обзор архитектуры

NanoVNA-X использует многослойную архитектуру, разделяющую этапы загрузки, аппаратную интеграцию, обработку измерений и пользовательский интерфейс. Такой подход позволяет поддерживать сопровождаемость и вписываться в строгие ограничения по объему флэш-памяти и оперативной памяти на микроконтроллерах STM32F072 и STM32F303.

* **Загрузка и выполнение приложения.** Прошивка стартует в `src/core/main.c`, где управление передается функции `app_main()`. Вся логика верхнего уровня сосредоточена в `src/app/application.c`: здесь инициализируется ChibiOS/RT, настраиваются USB-консоль и драйверы синтезатора, поднимается измерительный конвейер и запускается выделенный поток опроса, координирующий измерения, обновление интерфейса и обработку команд консоли.
* **Аппаратная абстракция.** Модуль `src/platform/platform_hal.c` обращается к таблице драйверов, зарегистрированной в `src/platform/boards/`, чтобы каждая поддерживаемая плата предоставляла структуру `PlatformDrivers` с инициализацией и описаниями периферии. Это изолирует ядро приложения от различий между NanoVNA-H (STM32F072) и NanoVNA-H4 (STM32F303).
* **Слой сервисов.** Общая инфраструктура расположена в каталоге `src/services/`. Шина событий реализует механизм публикации/подписки с фиксированным набором тем и при наличии буферов использует почтовый ящик, чтобы код из обработчиков прерываний мог отложенно доставлять сообщения. Хелпер планировщика оборачивает создание и завершение потоков ChibiOS, а сервис конфигурации отвечает за сохранение настроек пользователя и слотов калибровки во флэш-памяти с контролем целостности.
* **Измерительный конвейер и DSP.** Файл `src/measurement/pipeline.c` выступает тонким фасадом между платформенными драйверами и измерительными процедурами в `src/app/application.c`. Он делегирует выполнение свипа прикладному уровню и предоставляет текущую маску каналов. Численные помощники и математические алгоритмы калибровки вынесены в `src/dsp/`, чтобы изолировать ресурсоемкий код от прямого доступа к оборудованию.
* **Драйверы и middleware.** Низкоуровневые взаимодействия с железом реализованы в `src/drivers/` — здесь находятся драйверы дисплея, синтезатора Si5351, кодека TLV320 и USB-интерфейса. Каталог `src/middleware/` содержит небольшие интеграционные прослойки, например привязку `chprintf` к потокам ChibiOS. ChibiOS поставляется вместе с проектом в каталоге `third_party/` и конфигурируется через заголовки в `config/` и файлы верхнего уровня `chconf.h`/`halconf.h`.
* **Пользовательский интерфейс.** Поток опроса инициализирует инструментарий UI (`src/ui/`), обрабатывает аппаратный ввод, обновляет графики и отмечает области экрана для перерисовки. Шрифты и пиктограммы, используемые отрисовкой, хранятся в `src/resources/`.
* **Менеджер состояния.** Новый модуль `src/system/state_manager.c` занимает нишу между сервисом конфигурации и прикладным кодом: он поддерживает таблицы значений по умолчанию, восстанавливает backup-регистры, отслеживает «грязное» состояние и планирует отложенные записи во flash. UI и консоль обращаются к нему через заголовок `include/system/state_manager.h`, поэтому логика автосохранения сосредоточена в одном месте.

Публичные заголовки вынесены в `include/`, а поддержка плат, скрипты компоновки и стартовый код находятся в каталоге `boards/`. Такая структура позволяет использовать единые механизмы измерений и пользовательского интерфейса на обеих аппаратных платформах, ограничиваясь лишь точечными переопределениями.

## Структура репозитория

Чтобы упростить ориентацию в дереве исходников и отойти от линейного портирования старых форков, проект структурирован следующим образом:

| Путь | Назначение |
| --- | --- |
| `include/app`, `src/app` | Публичные API верхнего уровня — служба свипа, консоль, UI-прослойки и измерительный конвейер. |
| `include/services`, `src/services` | Повторно используемая инфраструктура (шина событий, конфигурация, планировщик, вспомогательные задачи). |
| `include/system`, `src/system` | Базовые системные компоненты, в частности `state_manager`, который отвечает за восстановление/сохранение состояния и работу с backup-регистрами. |
| `src/platform`, `boards/STM32F0/STM32F3` | Платы и аппаратно-зависимый код, общий с ChibiOS. |

При переносе патчей из наследованных деревьев важно сопоставлять функциональность с подходящим модулем, а не копировать файл целиком — теперь зависимость легко прослеживается по каталогу.

## Шина событий и планировщик

Шина событий (`services/event_bus.[ch]`) — это компактный помощник публикации/подписки без динамического выделения памяти. `event_bus_init()` принимает статический массив подписок, опциональные буферы почтового ящика (`msg_t`-очередь и длину) и набор узлов для очереди. Если заданы буферы, `event_bus_publish()` помещает сообщения в почтовый ящик, после чего отдельный поток вызывает `event_bus_dispatch()` и рассылает их подписчикам. При отсутствии почтового ящика уведомления доставляются синхронно. Обработчики прерываний должны пользоваться `event_bus_publish_from_isr()`, который резервирует узлы очереди с учётом блокировок. Предопределённые темы (`EVENT_SWEEP_STARTED`, `EVENT_SWEEP_COMPLETED`, `EVENT_TOUCH_INPUT`, `EVENT_STORAGE_UPDATED`, `EVENT_CONFIGURATION_CHANGED`, `EVENT_SHELL_COMMAND_PENDING`) покрывают текущие сценарии; для расширения шины нужно добавить элементы в перечисление `event_bus_topic_t`.

Планировщик (`services/scheduler.[ch]`) содержит фиксированный пул из четырёх слотов поверх `chThdCreateStatic()`/`chThdTerminate()`. Вызов `scheduler_start()` возвращает дескриптор со ссылкой на слот, чтобы позже можно было остановить задачу через `scheduler_stop()`. Планировщик не реализует собственное распределение квантов — приоритеты и тайминги остаются на стороне ChibiOS.

## Аппаратная платформа и используемые чипы
Основные целевые MCU — STM32F072xB и STM32F303 (NanoVNA-H/H4); плата F072 использует 8 МГц кварц, линии USB, SPI, I²C и I²S для дисплея, кодека и сенсора, как описано в board.h.

Тактовый генератор Si5351A (или совместимый) управляет выходными синтезаторами, а также формирует опорные частоты для аудио АЦП; драйвер реализует кэширование частот, управление мощностью и инициализацию PLL по I²C.

TLV320AIC3204 служит двухканальным аудио АЦП/ЦАП (I²S), с конфигурацией PLL и маршрутизацией входов; прошивка управляет им через I²C и выводит рабочий поток по SPI/I²S.

Дисплейные контроллеры ILI9341/ST7789 (320×240) и ST7796S (480×320) выбираются по плате; поддерживается DMA, регулировка яркости (для H4), инверсия и тени текста для повышения читаемости.

Дополнительные функции включают RTC, сохранение конфигурации и калибровок во внутренней флэш-памяти, USB UID, дистанционное управление, модуль измерений (LC matching, анализ кабеля и резонансов).

## Сборка прошивки

NanoVNA-X использует стандартный процесс на основе GNU Make и компилятора Arm GNU GCC.
Полное руководство приведено в файле [`doc/building.md`](doc/building.md), а ниже приведено краткое резюме шагов для чистой сборки.

### 1. Установите кросс-компилятор

Поддерживаются актуальные версии пакета `gcc-arm-none-eabi`; нет необходимости полагаться на архивные сборки.

#### macOS (Homebrew)

```
brew install gcc-arm-none-eabi dfu-util
```

#### Ubuntu / Debian

```
sudo apt update
sudo apt install gcc-arm-none-eabi libnewlib-arm-none-eabi dfu-util
```

После установки проверьте доступность компилятора:

```
arm-none-eabi-gcc --version
```

### 2. Получите исходный код

Клонируйте репозиторий и убедитесь, что сторонние зависимости инициализированы:

```
git clone https://github.com/momentics/NanoVNA-X.git
cd NanoVNA-X
git submodule update --init --recursive
```

Для последующего обновления до свежей ревизии достаточно выполнить `git pull`.

### 3. Соберите нужный профиль прошивки

Установите переменную окружения `TARGET`, чтобы выбрать плату, и запустите `make`.
При переключении между целями используйте `make clean`, чтобы избежать смешения артефактов.

```
export TARGET=F072   # NanoVNA-H (значение по умолчанию)
make clean
make -j$(nproc)
```

Для сборки прошивки NanoVNA-H4 задайте `TARGET=F303`.
Результаты компиляции записываются в каталог `build/` (`H.bin`/`H4.bin`, `.elf`, `.hex`).
См. файл [doc/building.md](doc/building.md) с пояснением, какой артефакт выбрать для прошивки по Device Firmware Upgrade (DFU — обновление встроенного программного обеспечения через USB), интерфейсу Serial Wire Debug (SWD — последовательный отладочный интерфейс) либо для отладчика.

### 4. Прошейте устройство

Переведите прибор в режим Device Firmware Upgrade (DFU) одним из способов:

* Откройте прибор и при подаче питания замкните контакт `BOOT0` на питание `Vdd`.
* Выберите в меню пункт System -> Device -> DFU (требуется актуальная прошивка).
* Нажмите энкодер NanoVNA-H4 при подаче питания.

Затем прошейте двоичный файл, созданный на предыдущем шаге:

```
export TARGET=F072
make flash
```

Цель `make flash` использует утилиту Device Firmware Upgrade Utility (`dfu-util`) и загружает соответствующий артефакт `build/H.bin` либо `build/H4.bin` для выбранной платы.
`dfu-util` выводит диагностические сообщения, например кратковременное предупреждение о «поврежденной прошивке» при выходе устройства из режима DFU; скрипт сборки автоматически очищает статус, и это сообщение можно игнорировать.

## Сопутствующие инструменты

Существует несколько качественных программных инструментов для персонального компьютера Personal Computer (PC), созданных сторонними разработчиками.

* [GoVNA](https://github.com/momentics/GoVNA): Надёжная и безопасная библиотека Go для управления векторными анализаторами цепей NanoVNA. Поддерживаются несколько протоколов (V1, V2/LiteVNA), автоматическое определение устройств и оптимизирована для высокопроизводительных серверных приложений.
* [PyVNA](https://github.com/momentics/PyVNA): Многопротокольная библиотека Python для NanoVNA V1/V2/LiteVNA, созданная на основе GoVNA для высокопроизводительных и безопасных серверных приложений. Поддерживает автоматическое определение, надёжное объединение устройств в пул и комплексную обработку данных.
* [NanoVNA-App software](https://github.com/OneOfEleven/NanoVNA-App) от OneOfEleven

## Документация

* [Структура меню NanoVNA-X (RU)](doc/menu_structure_ru.md) — подробное древо пунктов меню на русском языке.
* [NanoVNA-X menu structure](doc/menu_structure.md) — англоязычное дерево актуального меню NanoVNA-X.
* [NanoVNA-X menu & user workflow reference](doc/menu_and_user_guide.md) — англоязычное описание сценариев работы с меню.
* [NanoVNA User Guide (ja)](https://cho45.github.io/NanoVNA-manual/) от cho45. [(en: google translate)](https://translate.google.com/translate?sl=ja&tl=en&u=https%3A%2F%2Fcho45.github.io%2FNanoVNA-manual%2F)
* [Группа пользователей NanoVNA](https://groups.io/g/nanovna-users/topics) на портале groups.io.

## Справочные материалы

* [Схемотехника](/doc/nanovna-sch.pdf)
* [Фотография печатной платы](/doc/nanovna-pcb-photo.jpg)
* [Структурная схема](/doc/nanovna-blockdiagram.png)

## Примечание

Материалы по аппаратной части опубликованы, чтобы предотвратить появление некачественных копий.
Если у вас есть собственный экземпляр, пожалуйста, сообщите об этом.

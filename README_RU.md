<p align="center">
  <a href="https://github.com/momentics/NanoVNA-X/actions/workflows/firmware.yml"><img src="https://github.com/momentics/NanoVNA-X/actions/workflows/firmware.yml/badge.svg?branch=main" alt="Состояние непрерывной интеграции прошивки"></a>
  <a href="https://github.com/momentics/NanoVNA-X/actions/workflows/release-artifacts.yml"><img src="https://github.com/momentics/NanoVNA-X/actions/workflows/release-artifacts.yml/badge.svg" alt="Состояние сборки релизных артефактов"></a>
</p>

NanoVNA-X - усовершенствованная прошивка для карманных векторных анализаторов NanoVNA -H/H4
===============================================================================
[English version](README.md)
[![Release](https://img.shields.io/github/v/release/momentics/NanoVNA-X)](https://github.com/momentics/NanoVNA-X/releases)
[![Maintenance](https://img.shields.io/maintenance/yes/2025)]()

<div align="center">
<img src="/doc/NanoVNA.jpg" width="280px">
</div>

# О проекте

**NanoVNA-H** и **NanoVNA-H4** — это очень компактные переносные приборы класса Vector Network Analyzer (VNA — векторный анализатор цепей).
Они представляют собой автономные портативные устройства с дисплеем Liquid Crystal Display (LCD — жидкокристаллический индикатор) и аккумулятором.

Поддержкой NanoVNA-X занимается **@momentics** (https://github.com/momentics/). Проект оптимизирован под STM32F072 и STM32F303 с ограниченными ресурсами памяти и сегодня представляет собой самостоятельную архитектуру, ориентированную на отзывчивость, чёткие границы подсистем и детерминированную работу свипа. Прошивка распространяется под GNU GPLv3, поэтому каждый участник — от авторов исходной NanoVNA до нынешних разработчиков — сохраняет свои права.

Этот репозиторий содержит исходные тексты улучшенной прошивки NanoVNA-H и NanoVNA-H4, используемой в проекте NanoVNA-X.
Документация описывает процесс сборки и прошивки в среде macOS или Linux (Debian либо Ubuntu); другие дистрибутивы Linux (а также BSD) обычно ведут себя аналогично.

## Благодарности и дисклеймер

- Отдельная благодарность [@edy555](https://github.com/edy555) и [@DiSlord](https://github.com/DiSlord) за открытый релиз исходной NanoVNA. Именно их работа дала старт всему сообществу.
- NanoVNA-X активно развивается и сознательно уходит от блочного дизайна оригинала - свип, UI и подсистемы ввода теперь минимально связаны и синхронизируются через события ChibiOS и тайм-ауты.
- Цель проекта — сохранить привычный интерфейс NanoVNA и при этом построить поддерживаемый, модульный стек с полноценной работой microSD (калибровки, S1P/S2P, BMP/RLE-TIFF, дампы, скрипты и форматирование).

## Чем NanoVNA-X отличается от других прошивок

- **Слоистый runtime вместо монолитного `main.c`.** Поток свипа, консоль и сервисы собираются в `src/runtime/` через явные порты, поэтому управляющая логика читается и тестируется, а не скрывается внутри `app_main`.
- **Zero-copy конвейер свипа.** RF-орchestration строится вокруг снапшотов `sweep_service_snapshot_t` и координатора `measurement_engine`, что позволяет UI, USB-CLI и заданиям SD-карты потреблять уже захваченные буферы без повторных измерений.
- **Инфраструктура в `infra/`.** Шина событий, кооперативный планировщик, сервис конфигурации/калибровки и менеджер состояния с автосохранением заменяют жёстко впаянные глобалы из v0.9.1, делая фоновую работу предсказуемой и восстановимой.
- **Чистые интерфейсы.** CLI, USB-транспорт, UI-хуки и DSP-хелперы описаны в `include/interfaces/*`, что устраняет практику `#include "*.c"` и чётко показывает, где находится транспорт-независимая логика.
- **Переработанный UI и ввод.** Презентеры, контроллеры, адаптеры ввода, шрифты и иконки живут в `src/ui/`, благодаря чему реализованы браузер SD-карты, удалённый десктоп и улучшенные сообщения без правок драйверов железа.
- **Обновлённые инструменты и документация.** Единый файл `VERSION` обслуживает билд и релизы, Makefile знает новый план каталогов, а русские/английские документы описывают расхождения, чтобы форки понимали, чем современное дерево отличается от DiSlord.
- **Предсказуемая событийная архитектура.** Движок свипа, UI, USB CDC-оболочка и DSP взаимодействуют через шину событий ChibiOS и сторожевые тайм-ауты. Зависший кодек, синтезатор или ПК-хост больше не могут «подвесить» прибор во время калибровки.
- **DMA зарезервирован под измерения.** Передачи SPI LCD и приём данных TLV320 по I²S выполняются через DMA, а UART-консоль сознательно переведена на драйвер прерываний, чтобы каналы DMA всегда были доступны критичным трактам измерений.
- **Уникальный USB-серийный номер по умолчанию.** Каждое устройство теперь объявляется с номером, вычисленным по уникальному идентификатору микроконтроллера (при необходимости его всё ещё можно отключить в System -> Device -> MORE -> *USB DEVICE UID*).
- **Полностью интегрированная работа с картой microSD.** Меню SD CARD поддерживает сохранение и восстановление калибровок, экспорт S1P/S2P, получение скриншотов (BMP или компактный RLE-TIFF), выгрузку образа прошивки, запуск командных сценариев и форматирование карты контролируемой командой `FORMAT SD`, что соответствует сервисным процедурам Keysight и Rohde & Schwarz.

## Улучшения
Прошивка переписана на многослойной архитектуре ChibiOS, уделяющей максимум внимания отклику устройства, автономной работе и стабильности измерений на ограниченном железе.

### Стабильность и отзывчивость прошивки
Ядро прошивки было переработано. Вместо блокирующих вызовов теперь используется полностью асинхронная, событийно-ориентированная архитектура на основе примитивов ChibiOS (почтовые ящики, события и семафоры).
*   **Неблокирующий USB.** Стек USB CDC (виртуальный COM-порт) теперь полностью асинхронен. Прошивка больше не зависает, если хост-компьютер подключается, отключается или "тормозит" во время передачи данных. Это решает самую частую причину зависаний прибора.
*   **Восстановление по таймаутам.** Критически важные подсистемы, включая измерительный движок и шину I²C, защищены таймаутами. "Зависшая" операция больше не блокирует все устройство; вместо этого подсистема пытается корректно восстановить свою работу.
*   **Параллелизм на основе RTOS.** Циклы ожидания (busy-wait) и постоянные опросы были заменены на эффективные сигнальные механизмы RTOS, что снижает нагрузку на процессор и увеличивает время работы от батареи. Измерительный поток, пользовательский интерфейс и стек USB теперь работают согласованно, без гонок состояний и взаимоблокировок.
*   **Сохранение состояния.** Выделенный модуль `infra/state/state_manager` отслеживает лимиты свипа, флаги UI и активный слот калибровки. Изменения автоматически сбрасываются во flash после паузы редактирования (или мгновенно через пункт меню *SAVE CONFIG*), поэтому корректировки диапазонов переживают выключение без лишних циклов записи.
*   **Синхронизация UI и измерений.** Пользовательский интерфейс и измерительный движок теперь разделены. Интерфейс остается отзывчивым даже во время сложных вычислений, а данные на экране всегда синхронизированы с состоянием измерений.

### Производительность и управление ресурсами
*   **Целевая оптимизация памяти.** Потребление статической ОЗУ было значительно сокращено, особенно для STM32F072 (NanoVNA-H) с 16 КБ памяти. Это было достигнуто путем настройки размеров буферов, отключения таких функций, как кэширование трасс на моделях с малым объемом памяти, и перемещения ключевых буферов в CCM RAM на STM32F303.
*   **Стратегическое использование DMA.** Архитектура DMA была доработана для повышения стабильности измерений. DMA используется для самых требовательных путей данных:
    *   **Интерфейс дисплея (SPI).** Обеспечивает плавную и быструю отрисовку интерфейса и графиков.
    *   **Измерительный конвейер (I²S).** Гарантирует доставку сэмплов от кодека без потерь.
    *   Чтобы освободить каналы DMA для этих критических задач, **консоль UART была намеренно переведена на драйвер, работающий на прерываниях (без DMA).** Это предотвращает конфликты ресурсов и ставит в приоритет целостность измерений.

### Производительность свипа (STM32F072 как базовый уровень)
Измерения выполнены на серийном NanoVNA-H с типичным свипом из 101 точки:

| Сценарий | Эффективный поток точек |
| --- | --- |
| Диапазон 50 кГц–900 МГц без гармонических перебросов | 138–142 точки в секунду, разброс задаёт время стабилизации PLL Si5351. |
| Полный диапазон 50 кГц–2,7 ГГц с гармоническими перебросами (50–300 / 300–600 / 600–900 МГц и соответствующие гармоники) | 165–172 точки в секунду благодаря конвейерному движку свипа и оптимизированному расписанию IF-полосы. |

NanoVNA-H4 на STM32F303 работает быстрее за счёт большего объёма SRAM, однако приведённые значения задают гарантированный минимум для наименее мощной платформы.

### Новые функции и возможности
*   **Стабилизация PLL.** Последовательность программирования синтезатора Si5351 была оптимизирована для уменьшения выбросов и дрейфа частоты, что повышает повторяемость измерений, особенно в начале сканирования.
*   **Детерминированный USB-нумератор.** Режим USB DEVICE UID теперь включён по умолчанию, поэтому каждое устройство сразу объявляется с устойчивым серийным номером, распознаваемым NanoVNA-App, NanoVNA Saver и другими утилитами.

### Процесс сборки и разработки
*   **Автоматическое версионирование.** Версия прошивки теперь автоматически встраивается в процессе сборки из единого файла `VERSION`.
*   **Улучшенный CI/CD.** Рабочие процессы GitHub Actions были оптимизированы для более быстрых и надежных сборок с улучшенным кэшированием.
*   **Генерация DFU-файлов.** В процесс выпуска релизов интегрирован скрипт на Python для создания файлов прошивки, совместимых с DfuSe.

## Обзор архитектуры

NanoVNA-X использует многослойную архитектуру, разделяющую этапы загрузки, аппаратную интеграцию, обработку измерений и пользовательский интерфейс. Такой подход позволяет поддерживать сопровождаемость и вписываться в строгие ограничения по объему флэш-памяти и оперативной памяти на микроконтроллерах STM32F072 и STM32F303.

* **Загрузка и выполнение приложения.** Прошивка стартует в `src/runtime/main.c`, где управление передается функции `runtime_main()`. Вся логика верхнего уровня сосредоточена в `src/runtime/runtime_entry.c`. Здесь инициализируется ChibiOS/RT, настраиваются USB-консоль и драйверы синтезатора, поднимается измерительный конвейер и запускается выделенный поток опроса, координирующий измерения, обновление интерфейса и обработку команд консоли.
* **Аппаратная абстракция.** Модуль `src/platform/platform_hal.c` обращается к таблице драйверов, зарегистрированной в `src/platform/boards/`, чтобы каждая поддерживаемая плата предоставляла структуру `PlatformDrivers` с инициализацией и описаниями периферии. Это изолирует ядро приложения от различий между NanoVNA-H (STM32F072) и NanoVNA-H4 (STM32F303).
* **Слой сервисов.** Общая инфраструктура расположена в каталоге `src/infra/`. Шина событий реализует механизм публикации/подписки с фиксированным набором тем и при наличии буферов использует почтовый ящик, чтобы код из обработчиков прерываний мог отложенно доставлять сообщения. Хелпер планировщика оборачивает создание и завершение потоков ChibiOS, а сервис конфигурации отвечает за сохранение настроек пользователя и слотов калибровки во флэш-памяти с контролем целостности.
* **Измерительный конвейер и DSP.** Файл `src/rf/pipeline/measurement_pipeline.c` выступает тонким фасадом между платформенными драйверами и измерительными процедурами в `src/rf/sweep/`. Он делегирует выполнение свипа прикладному уровню и предоставляет текущую маску каналов. Численные помощники и математические алгоритмы калибровки вынесены в `src/processing/`, чтобы изолировать ресурсоемкий код от прямого доступа к оборудованию.
* **Драйверы и middleware.** Низкоуровневые взаимодействия с железом реализованы в `src/platform/peripherals/` — здесь находятся драйверы дисплея, синтезатора Si5351, кодека TLV320 и USB-интерфейса. Каталог `src/middleware/` содержит небольшие интеграционные прослойки, например привязку `chprintf` к потокам ChibiOS. ChibiOS поставляется вместе с проектом в каталоге `third_party/` и конфигурируется через заголовки в `config/` и файлы верхнего уровня `chconf.h`/`halconf.h`.
* **Пользовательский интерфейс.** Поток опроса инициализирует инструментарий UI (`src/ui/`), обрабатывает аппаратный ввод, обновляет графики и отмечает области экрана для перерисовки. Шрифты и пиктограммы, используемые отрисовкой, хранятся в `src/ui/resources/`.
* **Менеджер состояния.** Модуль `src/infra/state/state_manager.c` занимает нишу между сервисом конфигурации и прикладным кодом. Он поддерживает таблицы значений по умолчанию, восстанавливает backup-регистры, отслеживает «грязное» состояние и планирует отложенные записи во flash. UI и консоль обращаются к нему через заголовок `include/infra/state/state_manager.h`, поэтому логика автосохранения сосредоточена в одном месте.

Публичные заголовки вынесены в `include/`, а поддержка плат, скрипты компоновки и стартовый код находятся в каталоге `boards/`. Такая структура позволяет использовать единые механизмы измерений и пользовательского интерфейса на обеих аппаратных платформах, ограничиваясь лишь точечными переопределениями.

## Структура репозитория

Чтобы упростить ориентацию в дереве исходников и отойти от линейного портирования старых форков, проект структурирован следующим образом.

| Путь | Назначение |
| --- | --- |
| `include/runtime`, `src/runtime` | Публичные API верхнего уровня — точка входа, фичефлаги, консоль и координация свипов. |
| `include/rf`, `src/rf` | Свип-движок, измерительный конвейер и вспомогательная аналитика. |
| `include/processing`, `src/processing` | DSP и математические помощники, используемые измерениями и UI. |
| `include/infra`, `src/infra` | Повторно используемая инфраструктура (шина событий, конфигурация, планировщик, управление состоянием). |
| `include/interfaces`, `src/interfaces` | Чистые порты (CLI, USB, UI, обработка данных) для связи подсистем. |
| `include/ui`, `src/ui` | Отрисовка, контроллеры, ввод и ресурсы (шрифты/иконки). |
| `src/platform`, `boards/STM32F0`/`STM32F3` | Платы и аппаратно-зависимый код, общий с ChibiOS. |

При переносе патчей из наследованных деревьев важно сопоставлять функциональность с подходящим модулем, а не копировать файл целиком — теперь зависимость легко прослеживается по каталогу.

## Шина событий и планировщик

Шина событий (`infra/event/event_bus.[ch]`) — это компактный помощник публикации/подписки без динамического выделения памяти. `event_bus_init()` принимает статический массив подписок, опциональные буферы почтового ящика (`msg_t`-очередь и длину) и набор узлов для очереди. Если заданы буферы, `event_bus_publish()` помещает сообщения в почтовый ящик, после чего отдельный поток вызывает `event_bus_dispatch()` и рассылает их подписчикам. При отсутствии почтового ящика уведомления доставляются синхронно. Обработчики прерываний должны пользоваться `event_bus_publish_from_isr()`, который резервирует узлы очереди с учётом блокировок. Предопределённые темы (`EVENT_SWEEP_STARTED`, `EVENT_SWEEP_COMPLETED`, `EVENT_TOUCH_INPUT`, `EVENT_STORAGE_UPDATED`, `EVENT_CONFIGURATION_CHANGED`, `EVENT_USB_COMMAND_PENDING`) покрывают текущие сценарии; для расширения шины нужно добавить элементы в перечисление `event_bus_topic_t`.

Планировщик (`infra/task/scheduler.[ch]`) содержит фиксированный пул из четырёх слотов поверх `chThdCreateStatic()`/`chThdTerminate()`. Вызов `scheduler_start()` возвращает дескриптор со ссылкой на слот, чтобы позже можно было остановить задачу через `scheduler_stop()`. Планировщик не реализует собственное распределение квантов — приоритеты и тайминги остаются на стороне ChibiOS.

## Аппаратная платформа и используемые чипы
Основные целевые MCU — STM32F072xB и STM32F303 (NanoVNA-H/H4); плата F072 использует 8 МГц кварц, линии USB, SPI, I²C и I²S для дисплея, кодека и сенсора, как описано в board.h.

Тактовый генератор Si5351A (или совместимый) управляет выходными синтезаторами, а также формирует опорные частоты для аудио АЦП; драйвер реализует кэширование частот, управление мощностью и инициализацию PLL по I²C.

TLV320AIC3204 служит двухканальным аудио АЦП/ЦАП (I²S), с конфигурацией PLL и маршрутизацией входов; прошивка управляет им через I²C и выводит рабочий поток по SPI/I²S.

Дисплейные контроллеры ILI9341/ST7789 (320×240) и ST7796S (480×320) выбираются по плате; поддерживается DMA, регулировка яркости (для H4), инверсия и тени текста для повышения читаемости.

Дополнительные функции включают RTC, сохранение конфигурации и калибровок во внутренней флэш-памяти, USB UID, дистанционное управление, модуль измерений (LC matching, анализ кабеля и резонансов).

## Сборка прошивки

NanoVNA-X использует стандартный процесс на основе GNU Make и компилятора Arm GNU GCC.
Полное руководство приведено в файле [`doc/building.md`](doc/building.md), а ниже приведено краткое резюме шагов для чистой сборки.


## Сопутствующие инструменты

Существует несколько качественных программных инструментов для персонального компьютера Personal Computer (PC), созданных сторонними разработчиками.

* [GoVNA](https://github.com/momentics/GoVNA). Надёжная и безопасная библиотека Go для управления векторными анализаторами цепей NanoVNA. Поддерживаются несколько протоколов (V1, V2/LiteVNA), автоматическое определение устройств и оптимизирована для высокопроизводительных серверных приложений.
* [PyVNA](https://github.com/momentics/PyVNA). Многопротокольная библиотека Python для NanoVNA V1/V2/LiteVNA, созданная на основе GoVNA для высокопроизводительных и безопасных серверных приложений. Поддерживает автоматическое определение, надёжное объединение устройств в пул и комплексную обработку данных.
* [NanoVNA-App software](https://github.com/OneOfEleven/NanoVNA-App) от OneOfEleven

## Документация

* [Структура меню NanoVNA-X (RU)](doc/menu_structure_ru.md) — подробное древо пунктов меню на русском языке.
* [NanoVNA-X menu structure](doc/menu_structure.md) — англоязычное дерево актуального меню NanoVNA-X.
* [NanoVNA-X menu & user workflow reference](doc/menu_and_user_guide.md) — англоязычное описание сценариев работы с меню.
* [NanoVNA User Guide (ja)](https://cho45.github.io/NanoVNA-manual/) от cho45. [(en: google translate)](https://translate.google.com/translate?sl=ja&tl=en&u=https%3A%2F%2Fcho45.github.io%2FNanoVNA-manual%2F)
* [Группа пользователей NanoVNA](https://groups.io/g/nanovna-users/topics) на портале groups.io.

## Справочные материалы

* [Схемотехника](/doc/nanovna-sch.pdf)
* [Фотография печатной платы](/doc/nanovna-pcb-photo.jpg)
* [Структурная схема](/doc/nanovna-blockdiagram.png)

## Примечание

Материалы по аппаратной части опубликованы, чтобы предотвратить появление некачественных копий.
Если у вас есть собственный экземпляр, пожалуйста, сообщите об этом.

# Спецификация USB-протокола обмена NanoVNA-X

## 1. Обзор транспортного уровня
NanoVNA-X предоставляет интерфейс USB CDC ACM, реализованный стеком ChibiOS serial-over-USB. Устройство определяется с идентификатором производителя `0x0483` (STMicroelectronics) и идентификатором продукта `0x5740`. Версия устройства по умолчанию — `0x0200`. Конфигурация содержит один коммуникационный интерфейс CDC и один интерфейс передачи данных. Назначение конечных точек:

| Endpoint | Направление | Тип       | Размер пакета | Назначение |
|---------:|-------------|-----------|---------------|------------|
| 0x01     | OUT         | Bulk      | 64 байта      | Поток команд от хоста к устройству |
| 0x81     | IN          | Bulk      | 64 байта      | Ответы и данные устройства |
| 0x82     | IN          | Interrupt | 8 байт        | CDC-уведомления |

Строки дескрипторов содержат производителя `nanovna.com`, имя продукта зависит от конфигурации NanoVNA, а серийный номер может формироваться из уникального идентификатора МК при включённом `__USB_UID__`.

## 2. Кадрирование сеанса
Связь по USB CDC выглядит как виртуальный последовательный порт. Настраивать скорость передачи не требуется: команды и ответы передаются текстом ASCII и завершаются парой символов `\r\n`. Прошивка эхоирует введённые символы и выводит приглашение `ch> `, когда готова принять команду. Сразу после подключения устройство отправляет последовательность `\r\nch> \r\nNanoVNA Shell\r\nch> `, чтобы программы автодетекта могли распознать приглашение до баннера.

Команды чувствительны к регистру. Аргументы разделяются пробелами или табуляцией. Чтобы передать аргумент с пробелами, используйте двойные кавычки. Числовой парсер понимает десятичную запись по умолчанию, а также префиксы `0x` (шестнадцатеричная), `0o` (восьмеричная), `0b` (двоичная) и инженерные суффиксы `k`, `M`, `G`, `m`, `u`, `n` для вещественных значений.

Если команда не распознана, устройство печатает `<имя>?` и перевод строки. При ошибках аргументов выводятся подсказки по использованию.

## 3. Жизненный цикл команд и параллелизм
Каждый обработчик команды описывается набором флагов, которые влияют на выполнение:

* `CMD_WAIT_MUTEX` — команда выполняется основным UI-потоком после освобождения измерительного сервиса. С точки зрения хоста необходимо дождаться ответа и появления приглашения.
* `CMD_BREAK_SWEEP` — перед выполнением команда запрашивает паузу измерительного цикла.
* `CMD_RUN_IN_UI` — команда может выполняться даже когда управление sweep-мьютексом удерживает пользовательский интерфейс.
* `CMD_RUN_IN_LOAD` — обработчик разрешён во время загрузки конфигурации при старте.

Команды, меняющие параметры свипа, как правило, приостанавливают генерацию, вносят изменения и, при необходимости, возобновляют работу. Длительные операции (измерение, работа с файловой системой) не отправляют дополнительных подтверждений — дождитесь приглашения `ch> `, прежде чем отправлять следующую команду.

## 4. Форматы двоичных данных
Большинство ответов текстовые. При передаче двоичных данных прошивка записывает содержимое памяти в поток без дополнительного кадрирования:

* Целые числа и битовые поля используют порядок байт МК (little-endian на STM32).
* Частоты (`freq_t`) — 32-битные беззнаковые значения в герцах.
* Комплексные образцы — 32-битные числа с плавающей точкой IEEE-754 в формате `[действительная, мнимая]`.
* Для удалённого рабочего стола используется структура `remote_region_t` (`char new_str[6]; int16_t x, y, w, h`).

Хост должен знать ожидаемый объём полезной нагрузки для каждой команды, возвращающей бинарные данные.

## 5. Справочник команд
Команды сгруппированы тематически и перечислены в алфавитном порядке. Необязательные команды помечены соответствующими макросами компиляции.

### 5.1 Настройка свипа и управление измерениями
* `bandwidth {count} | bandwidth {frequency_Hz} {measured_bw}` — Настроить или запросить полосу пропускания ПЧ. Один аргумент задаёт счётчик (0–511). При двух аргументах прошивка подбирает ближайший счётчик под требуемую частоту. Ответ содержит активный счётчик и фактическую полосу.
* `config {auto|avg|connection|mode|grid|dot|bk|flip|separator|tif} {0|1}` (`ENABLE_CONFIG_COMMAND`) — Переключает режимы UI и измерений. Параметр `connection` выбирает консоль USB или UART, `bk` управляет использованием резервного питания RTC и т. д. При неверных аргументах выводится подсказка.
* `freq {frequency_Hz}` — Переход в режим непрерывного тона (CW) на указанной частоте. Свип приостанавливается на время перестройки генератора.
* `measure {mode}` (`__VNA_MEASURE_MODULE__`) — Выбор режима постобработки (например, `lc`, `filter`, `cable`). При неподдерживаемом режиме печатается инструкция.
* `offset {frequency_offset_Hz}` (`USE_VARIABLE_OFFSET`) — Устанавливает глобальный частотный сдвиг генератора в герцах.
* `pause` — Немедленно остановить текущий свип.
* `power {0-3|255}` — Настроить мощность выхода Si5351 (255 — автоматический выбор). При отсутствии аргументов печатается текущее значение.
* `resume` — Пересобрать таблицы частот и возобновить непрерывный свип.
* `scan {start_Hz} {stop_Hz} [points] [mask]` — Выполнить свип в заданном диапазоне. `points` по умолчанию равен текущему количеству точек. `mask` определяет формат ответа (см. ниже). Без маски команда только обновляет внутренние буферы.
* `scan_bin ...` (`ENABLE_SCANBIN_COMMAND`) — Перед вызовом `scan` принудительно включает двоичный вывод, устанавливая бит `SWEEP_BINARY`.
* `smooth {0-8}` (`__USE_SMOOTH__`) — Управляет сглаживанием результатов измерения методом скользящего среднего.
* `sweep {start_Hz} [stop_Hz] [points]` — Задать границы свипа и, при необходимости, количество точек. Альтернативный синтаксис `sweep {start|stop|center|span|cw|step|var} {value}` изменяет отдельный параметр.
* `tcxo {frequency_Hz}` — Настроить частоту внешнего опорного генератора.
* `threshold {frequency_Hz}` — Задать границу перехода в гармонический режим.
* `transform {on|off|impulse|step|bandpass|mininum|normal|maximum}` (`ENABLE_TRANSFORM_COMMAND`) — Включить преобразование в временную область и выбрать окно.

**Биты маски `scan`** (суммируются или объединяются по OR):

| Бит | Значение | Назначение |
|----:|---------:|------------|
| 0   | 0x01     | Добавить частоты |
| 1   | 0x02     | Добавить данные канала 0 (S11) |
| 2   | 0x04     | Добавить данные канала 1 (S21) |
| 3   | 0x08     | Игнорировать калибровку |
| 4   | 0x10     | Игнорировать электрические задержки |
| 5   | 0x20     | Игнорировать поправку S21 |
| 7   | 0x80     | Отправить бинарный поток вместо текста |

При установленном двоичном бите ответ начинается с 16-битных значения маски и числа точек, далее следуют выбранные записи в указанном порядке. Частоты передаются как `freq_t`, комплексные образцы — парами чисел с плавающей точкой.

### 5.2 Доступ к данным
* `capture [rle]` — Считать кадр из видеобуфера. Без аргументов выдаётся массив размером `LCD_WIDTH × LCD_HEIGHT × 2` байт в формате RGB565, строки подряд. При наличии аргумента и включённом `__CAPTURE_RLE8__` формируется заголовок BMP, длина палитры, сама палитра и строки, упакованные алгоритмом PackBits.
* `data [index]` — Вывести последнюю комплексную выборку. Индекс `0` — текущие данные S11, `1` — S21, `2…6` — сохранённые массивы калибровки (`load`, `open`, `short`, `thru`, `isoln`). Каждая строка содержит `действительная мнимая`.
* `frequencies` — Распечатать список рабочих частот, по одной в строке.
* `scan` — см. раздел 5.1.

### 5.3 Калибровка, трассы и маркеры
* `cal` — Без аргументов показывает, какие этапы калибровки выполнены. Аргументы: `load`, `open`, `short`, `thru`, `isoln` — измерение соответствующих эталонов; `done` — расчёт матрицы ошибок; `on`/`off` — включение или отключение калибровки; `reset` — очистка состояния.
* `edelay [s11|s21] {picoseconds}` — Запросить или задать электрическую задержку канала в пикосекундах (внутренне хранится в секундах).
* `marker` — Без аргументов перечисляет активные маркеры с индексами и частотой. `marker on|off` — включить/отключить все маркеры, `marker {n}` — выбрать маркер `n`, `marker {n} on|off` — включить или выключить конкретный маркер, `marker {n} {index}` — переместить маркер на заданный индекс свипа.
* `s21offset {dB}` — Запросить или изменить логарифмическую поправку к отображению S21.
* `save {slot}` / `recall {slot}` — Сохранить или восстановить калибровку и настройки из указанного слота.
* `trace` — Управлять отображением трасс. Без аргументов перечисляет включённые трассы с типом, каналом, масштабом и позицией нулевой линии. `trace {n}` выводит сведения по трассе `n`. `trace {n} off` отключает трассу. `trace {n} {type} [channel]` меняет тип измерения, `trace {n} scale {value}` и `trace {n} refpos {value}` — параметры отображения. Для формата смиттовских диаграмм поддерживаются значения `lin`, `ri`, `rlc` и др.

### 5.4 Хранение данных и конфигурации
* `clearconfig {1234}` — Полный сброс пользовательских настроек и калибровки (требуется ключ `1234`).
* `saveconfig` — Сохранить текущую конфигурацию.
* `sd_list [pattern]`, `sd_read {filename}`, `sd_delete {filename}` (`ENABLE_SD_CARD_COMMAND`) — Работа с картой SD: перечисление файлов (шаблон по умолчанию `*.*`), чтение файла (ответ начинается с 32-битного размера, далее следуют байты файла), удаление.

### 5.5 Системная информация и диагностика
* `band {idx} {mode} {value}` (`ENABLE_BAND_COMMAND`) — Настройка таблиц диапазонов Si5351.
* `dac {0-4095}` (`__VNA_ENABLE_DAC__`) — Установка значения внешнего ЦАП.
* `gain {lgain} [rgain]` (`ENABLE_GAIN_COMMAND`) — Настройка усилителей TLV320AIC3204.
* `info` (`ENABLE_INFO_COMMAND`) — Вывести строки массива `info_about[]` с описанием сборки прошивки.
* `reset [dfu]` — Перезагрузить устройство, при наличии `__DFU_SOFTWARE_MODE__` возможно переключение в режим DFU.
* `stat` (`ENABLE_STAT_COMMAND`) — Снять «сырые» данные АЦП и вывести средние/СКЗ.
* `tcxo`, `threshold`, `version`, `vbat`, `vbat_offset` — см. разделы 5.1 и 5.3. `version` печатает `NANOVNA_VERSION_STRING`; `vbat` — текущее напряжение аккумулятора в милливольтах; `vbat_offset` — смещение калибровки измерителя.
* `threads` (`ENABLE_THREADS_COMMAND`) — Сводка по потокам ChibiOS: размер стека, приоритеты, состояния.
* `time` (`__USE_RTC__`) — Работа с часами реального времени. Без аргументов выводит дату и время. `time b {YYMMDD_hex} {HHMMSS_hex}` записывает регистры напрямую. Отдельные поля (`y`, `m`, `d`, `h`, `min`, `sec`, `ppm`) можно задавать десятичными значениями.
* `usart_cfg {baud}` / `usart {string} [timeout_ms]` (`ENABLE_USART_COMMAND` и `__USE_SERIAL_CONSOLE__`) — Настройка UART-консоли и пересылка строк. `usart` отправляет строку (с переводом строки) по UART и ретранслирует ответ в USB до истечения тайм-аута.

### 5.6 Удалённый интерфейс и автоматизация
* `msg {delay_ms} [text] [header]` (`__SD_CARD_LOAD__`) — Показать диалоговое окно на указанное время.
* `refresh {on|off}` (`__REMOTE_DESKTOP__`) — Включить (`on`) или отключить (`off`) поток обновлений экрана. При активном USB CDC устройство периодически отправляет заголовок `remote_region_t`, затем пиксели изменённых областей и завершает обновление обычным приглашением.
* `touch {x} {y}` / `release [x y]` (`__REMOTE_DESKTOP__`) — Сгенерировать удалённое нажатие или отпускание. Координата `-1` оставляет предыдущее значение.
* `touchcal`, `touchtest` — Запуск калибровки или теста сенсорного экрана.

### 5.7 Инженерные утилиты
* `dump [selection]` (`ENABLED_DUMP_COMMAND`) — Снять массив IQ-данных для отладки.
* `i2c {page} {reg} {data}` (`ENABLE_I2C_COMMAND`) — Запись в регистры кодека TLV320AIC3204.
* `i2c {timing}` (`ENABLE_I2C_TIMINGS`) — Низкоуровневая настройка таймингов шины I²C.
* `lcd {cmd} [byte ...]` (`ENABLE_LCD_COMMAND`) — Отправка команд контроллеру ЖКИ и вывод кода возврата.
* `sample {gamma|ampl|ref}` (`ENABLE_SAMPLE_COMMAND`) — Выбор диагностического источника данных.
* `si {reg} {value}` (`ENABLE_SI5351_REG_WRITE`) — Прямая запись в регистры Si5351.
* `test` (`ENABLE_TEST_COMMAND`) — Резервная команда для отладки (по умолчанию без вывода).

### 5.8 Помощь и обнаружение возможностей
* `help` — Список зарегистрированных команд.
* `version`, `info` и `help` безопасно вызывать сразу после подключения.

## 6. Примеры обмена
1. **Получение версии прошивки**
   ```text
   ch> version\r\n
   NanoVNA-X ...\r\n
   ch> 
   ```
2. **Свип из 201 точки и получение текстовых данных**
   ```text
   ch> sweep 50000000 150000000 201\r\n
   ch> scan 50000000 150000000 201 0x03\r\n
   50000000 0.123456 -0.234567 0.345678 -0.456789\r\n
   ...
   ch> 
   ```
3. **Получение двоичных данных свипа**
   *Команда:* `scan 50000000 150000000 201 0x83\r\n`
   *Ответ:* первые четыре байта содержат маску `0x0083` и количество точек `0x00C9` (201), далее следуют записи частоты (`uint32_t`) и выбранных комплексных значений (`float[2]`).
4. **Чтение файла с карты SD**
   ```text
   ch> sd_read log.csv\r\n
   <4-byte size><binary file data>ch> 
   ```
5. **Снимок экрана в формате RGB565**
   ```text
   ch> capture\r\n
   <LCD_WIDTH * LCD_HEIGHT * 2 bytes of pixel data>ch> 
   ```

## 7. Обработка ошибок и рекомендации
* Отправляйте новую команду только после появления приглашения `ch> `. Операции свипа и файловой системы могут занимать сотни миллисекунд.
* На стороне хоста проверяйте длину двоичных блоков — дополнительных разделителей нет.
* Для длинных текстовых ответов (`scan` без двоичного режима, `data`, `frequencies`) по необходимости дросселируйте обработку — прошивка периодически уступает управление, но не дозирует скорость вывода.
* При автоматизации используйте `pause`/`resume` или маски `scan`, чтобы не мешать текущему свипу.

## 8. Необязательные возможности
Наличие некоторых команд определяется конфигурацией при сборке. Основные макросы:

| Макрос | Что включает |
|--------|--------------|
| `__REMOTE_DESKTOP__` | Поток удалённого экрана (`refresh`, `touch`, `release`). |
| `__USE_SD_CARD__` + `ENABLE_SD_CARD_COMMAND` | Команды работы с SD-картой. |
| `__VNA_MEASURE_MODULE__` | Расширенные режимы `measure`. |
| `__USE_SMOOTH__` | Команда `smooth`. |
| `ENABLE_SCANBIN_COMMAND` | Помощник двоичного `scan`. |
| `ENABLE_CONFIG_COMMAND` | Консольные переключатели `config`. |
| `ENABLE_USART_COMMAND` и `__USE_SERIAL_CONSOLE__` | Команды мостика UART. |
| `ENABLE_*` | Диагностические утилиты (`gain`, `stat`, `threads` и т. д.). |

Перед интеграцией проверьте конфигурацию прошивки и убедитесь, что нужные функции доступны.

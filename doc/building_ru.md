# Сборка прошивки NanoVNA-X

Это руководство описывает воспроизводимый процесс сборки прошивки NanoVNA-X из исходных текстов.
Приведенные ниже шаги проверены в средах macOS, Ubuntu/Debian и в среде выполнения GitHub Actions runner.
Другие операционные системы семейства Unix обычно подходят при наличии того же кросс-компилятора Arm GNU Compiler Collection (GCC — набор компиляторов GNU).

## 1. Установите необходимые компоненты

NanoVNA-X предназначен для микроконтроллеров семейства ARM Cortex-M, поэтому требуется инструментальная цепочка `arm-none-eabi`, а также утилита Device Firmware Upgrade Utility (`dfu-util`) для прошивки оборудования.

### Ubuntu / Debian

```bash
sudo apt update
sudo apt install gcc-arm-none-eabi libnewlib-arm-none-eabi dfu-util
```

### macOS (Homebrew)

```bash
brew install gcc-arm-none-eabi dfu-util
```

### Windows

Используйте Windows Subsystem for Linux 2 (WSL2 — подсистема Linux для Windows) с дистрибутивом Ubuntu и следуйте инструкциям для Linux, приведенным выше.
Нативная сборка в Windows возможна при использовании архивного дистрибутива Arm GNU toolchain, однако проект проходит тестирование в Unix-подобных средах.

Проверьте доступность компилятора:

```bash
arm-none-eabi-gcc --version
```

## 2. Получите исходный код

Клонируйте репозиторий — все сторонние компоненты (ChibiOS) уже входят в дерево исходников:

```bash
git clone https://github.com/momentics/NanoVNA-X.git
cd NanoVNA-X
```

### 2.1 Структура дерева исходников

Проект перестал быть простым линейным форком (ответвлением) — код распределён по слоям:

| Путь | Назначение |
| --- | --- |
| `include/runtime`, `src/runtime` | Прикладные API верхнего уровня: точка входа, флаги функциональности, координация свипов и консоль. |
| `include/rf`, `src/rf` | Механизм свипирования, измерительный конвейер и сопутствующая аналитика. |
| `include/processing`, `src/processing` | DSP и математические помощники для измерений и UI. |
| `include/sys`, `src/sys` | Общая инфраструктура (конфигурация, планировщик, шина событий, менеджер состояния). |
| `include/driver`, `src/driver` | Драйверы оборудования (LCD, кодек, синтезатор, USB). |
| `include/ui`, `src/ui` | Отрисовка, контроллеры, адаптеры ввода и встроенные ресурсы (шрифты/иконки). |
| `boards/STM32F072`, `boards/STM32F303` | Пакеты поддержки плат, общие с ChibiOS. |

При добавлении функций ориентируйтесь на эти каталоги, чтобы зависимости оставались однонаправленными.

## 3. Выберите целевую платформу

Прошивка собирается для двух аппаратных профилей.
Выберите целевую плату, установив переменную окружения `TARGET` перед запуском `make`:

| Target | Плата               | Профиль микроконтроллера |
|--------|---------------------|--------------------------|
| F072   | NanoVNA-H (по умолчанию) | STM32F072 |
| F303   | NanoVNA-H4          | STM32F303 |

Если переменная `TARGET` не указана, сборка по умолчанию выполняется для `F072`.

## 4. Соберите прошивку

Используйте стандартный процесс GNU Make:

```bash
export TARGET=F072   # или F303
make clean           # необязательная команда, но рекомендуемая при смене цели
make -j$(nproc)
```

В среде macOS используйте `make -j$(sysctl -n hw.ncpu)` для параллельной сборки.

Артефакты сборки размещаются в каталоге `build/`:

- `build/H.elf` / `build/H4.elf` — образ Executable and Linkable Format (ELF — стандартный формат исполняемых файлов) для отладки.
- `build/H.bin` / `build/H4.bin` — двоичный файл для прошивки по Device Firmware Upgrade (DFU — обновление встроенного программного обеспечения через USB).
- `build/H.hex` / `build/H4.hex` — образ в формате Intel HEX.

### 4.1 Разберите назначение артефактов

Каждый созданный файл служит собственной задаче.
Используйте вариант, соответствующий инструментам в вашей лаборатории или производственной линии:

| Артефакт       | Типичные инструменты                                         | Когда выбрать |
|----------------|---------------------------------------------------------------|---------------|
| `.bin` (сырые данные) | Device Firmware Upgrade Utility (`dfu-util`), `dfuse-tool`, STM32CubeProgrammer (USB — Universal Serial Bus) | Основной выбор для обновлений на месте через USB DFU. Соответствует структуре, ожидаемой `make flash`, и пакетам `.dfu`, публикуемым в релизах. |
| `.hex` (Intel) | ST-Link Utility, STM32CubeProgrammer (интерфейсы Serial Wire Debug (SWD) / Joint Test Action Group (JTAG)), стенды производственного программирования | Требуется, когда программатор принимает только файлы Intel HEX (текстовый формат) или когда необходимы адресные метки для ручного анализа. |
| `.elf` (отладочный) | GNU Debugger multi-architecture (`gdb-multiarch`), Open On-Chip Debugger (OpenOCD), Lauterbach, аппаратные отладчики | Содержит таблицы символов и метаданные секций. Используйте для пошаговой отладки, формирования файлов `.map` или исследования сбоев. |

Релизные сборки в GitHub публикуют тот же набор файлов для обеих плат.
Их можно прошивать без локальной пересборки.
Пакеты `.dfu` на странице релизов содержат файл `.bin` вместе с метаданными USB, чтобы такие инструменты, как Windows DfuSe, сразу распознавали образ.
Прошивка через `make flash` или `dfu-util` возможна как с исходным `.bin`, так и с артефактом `.dfu`.

## 5. Конфигурация сборки и опции

В файле `Makefile` определены флаги компиляции `UDEFS`. Из-за ограничений памяти
(особенно на STM32F072) некоторые функции могут быть отключены по умолчанию.

### Конфигурация для F072 (NanoVNA-H)

Из-за лимита в 128 кБ Flash памяти применяются следующие оптимизации:

- **Включено:** `__VNA_Z_RENORMALIZATION__` (Поддержка 75 Ом и смены импеданса).
- **Отключено:** `ENABLED_DUMP_COMMAND` (Команда `dump` для выгрузки сырого аудио через USB).
- **Отключено:** `VNA_AUTO_SELECT_RTC_SOURCE` (Автовыбор источника часов LSE/LSI).

### Конфигурация для F303 (NanoVNA-H4)

На F303 достаточно памяти, поэтому все функции включены по умолчанию:

- `__VNA_Z_RENORMALIZATION__`
- `ENABLED_DUMP_COMMAND`
- `VNA_AUTO_SELECT_RTC_SOURCE`

## 6. Прошейте устройство (по желанию)

Переведите оборудование в режим Device Firmware Upgrade (DFU) и прошейте созданный двоичный файл с помощью Device Firmware Upgrade Utility (`dfu-util`):

```bash
export TARGET=F072
make flash
```

Цель `flash` всегда использует двоичный файл из каталога `build/` для выбранного аппаратного профиля.
Устройство должно определиться на хосте как интерфейс DFU; подробности о переходе в этот режим приведены в основном файле README.

## 7. Устранение неполадок

- **Компилятор недоступен** — убедитесь, что `arm-none-eabi-gcc` находится в переменной `PATH`, и установлены перечисленные пакеты.
- **Старые артефакты сборки** — выполняйте `make clean` при смене целевой платы или после обновления инструментов, чтобы исключить несовместимость объектных файлов.
- **Ошибки доступа при прошивке** — в Linux добавьте правила udev для устройств DFU или запускайте `dfu-util` с `sudo`.
- **ПК не видит устройство** — после прошивки откройте USB-консоль и убедитесь, что сеанс начинается с баннера `NanoVNA-X Shell`, за которым следует приглашение `ch>`. Старые версии программ (например, NanoVNA-Saver) могут потребовать переподключения, чтобы правильно обработать приветствие.

Следуя этим шагам, вы получите воспроизводимую сборку как локально, так и в средах непрерывной интеграции (CI).

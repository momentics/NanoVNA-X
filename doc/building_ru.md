# Сборка прошивки NanoVNA-X

Это руководство описывает воспроизводимый процесс сборки прошивки NanoVNA-X из исходных текстов.
Приведенные ниже шаги проверены в средах macOS, Ubuntu/Debian и в среде выполнения GitHub Actions runner.
Другие операционные системы семейства Unix обычно подходят при наличии того же кросс-компилятора Arm GNU Compiler Collection (GCC — набор компиляторов GNU).

## 1. Установите необходимые компоненты

NanoVNA-X предназначен для микроконтроллеров семейства ARM Cortex-M, поэтому требуется инструментальная цепочка `arm-none-eabi`, а также утилита Device Firmware Upgrade Utility (`dfu-util`) для прошивки оборудования.

### Ubuntu / Debian

```bash
sudo apt update
sudo apt install gcc-arm-none-eabi libnewlib-arm-none-eabi dfu-util
```

### macOS (Homebrew)

```bash
brew install gcc-arm-none-eabi dfu-util
```

### Windows

Используйте Windows Subsystem for Linux 2 (WSL2 — подсистема Linux для Windows) с дистрибутивом Ubuntu и следуйте инструкциям для Linux, приведенным выше.
Нативная сборка в Windows возможна при использовании архивного дистрибутива Arm GNU toolchain, однако проект проходит тестирование в Unix-подобных средах.

Проверьте доступность компилятора:

```bash
arm-none-eabi-gcc --version
```

## 2. Получите исходный код

Клонируйте репозиторий — все сторонние компоненты (ChibiOS и FatFs) уже входят в дерево исходников:

```bash
git clone https://github.com/momentics/NanoVNA-X.git
cd NanoVNA-X
```

## 3. Выберите целевую плату

Прошивка собирается для двух аппаратных профилей.
Выберите целевую плату, установив переменную окружения `TARGET` перед запуском `make`:

| Target | Плата               | Профиль микроконтроллера |
|--------|---------------------|--------------------------|
| F072   | NanoVNA-H (по умолчанию) | STM32F072 |
| F303   | NanoVNA-H4          | STM32F303 |

Если переменная `TARGET` не указана, сборка по умолчанию выполняется для `F072`.

## 4. Соберите прошивку

Используйте стандартный процесс GNU Make:

```bash
export TARGET=F072   # или F303
make clean           # необязательная команда, но рекомендуемая при смене цели
make -j$(nproc)
```

В среде macOS используйте `make -j$(sysctl -n hw.ncpu)` для параллельной сборки.

Артефакты сборки размещаются в каталоге `build/`:

- `build/H.elf` / `build/H4.elf` — образ Executable and Linkable Format (ELF — стандартный формат исполняемых файлов) для отладки.
- `build/H.bin` / `build/H4.bin` — двоичный файл для прошивки по Device Firmware Upgrade (DFU — обновление встроенного программного обеспечения через USB).
- `build/H.hex` / `build/H4.hex` — образ в формате Intel HEX.

### 4.1 Разберите назначение артефактов

Каждый созданный файл служит собственной задаче.
Используйте вариант, соответствующий инструментам в вашей лаборатории или производственной линии:

| Артефакт       | Типичные инструменты                                         | Когда выбрать |
|----------------|---------------------------------------------------------------|---------------|
| `.bin` (сырые данные) | Device Firmware Upgrade Utility (`dfu-util`), `dfuse-tool`, STM32CubeProgrammer (USB — Universal Serial Bus) | Основной выбор для обновлений на месте через USB DFU. Соответствует структуре, ожидаемой `make flash`, и пакетам `.dfu`, публикуемым в релизах. |
| `.hex` (Intel) | ST-Link Utility, STM32CubeProgrammer (интерфейсы Serial Wire Debug (SWD) / Joint Test Action Group (JTAG)), стенды производственного программирования | Требуется, когда программатор принимает только файлы Intel HEX (текстовый формат) или когда необходимы адресные метки для ручного анализа. |
| `.elf` (отладочный) | GNU Debugger multi-architecture (`gdb-multiarch`), Open On-Chip Debugger (OpenOCD), Lauterbach, аппаратные отладчики | Содержит таблицы символов и метаданные секций. Используйте для пошаговой отладки, формирования файлов `.map` или исследования сбоев. |

Релизные сборки в GitHub публикуют тот же набор файлов для обеих плат.
Их можно прошивать без локальной пересборки.
Пакеты `.dfu` на странице релизов содержат файл `.bin` вместе с метаданными USB, чтобы такие инструменты, как Windows DfuSe, сразу распознавали образ.
Прошивка через `make flash` или `dfu-util` возможна как с исходным `.bin`, так и с артефактом `.dfu`.

## 5. Прошейте устройство (по желанию)

Переведите оборудование в режим Device Firmware Upgrade (DFU) и прошейте созданный двоичный файл с помощью Device Firmware Upgrade Utility (`dfu-util`):

```bash
export TARGET=F072
make flash
```

Цель `flash` всегда использует двоичный файл из каталога `build/` для выбранного аппаратного профиля.
Устройство должно определиться на хосте как интерфейс DFU; подробности о переходе в этот режим приведены в основном файле README.

## 6. Устранение неполадок

- **Компилятор недоступен** — убедитесь, что `arm-none-eabi-gcc` находится в переменной `PATH`, и установлены перечисленные пакеты.
- **Старые артефакты сборки** — выполняйте `make clean` при смене целевой платы или после обновления инструментов, чтобы исключить несовместимость объектных файлов.
- **Ошибки доступа при прошивке** — в Linux добавьте правила udev для устройств DFU или запускайте `dfu-util` с `sudo`.
- **ПК не видит устройство** — после прошивки откройте USB-консоль и убедитесь, что сеанс начинается с `ch> ` перед баннером. Старые версии программ (например NanoVNA-Saver) могут потребовать переподключения, чтобы принять новый формат приветствия.


Следуя этим шагам, вы получите воспроизводимую сборку как локально, так и в средах непрерывной интеграции Continuous Integration (CI — непрерывная интеграция).

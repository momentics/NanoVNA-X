name: Firmware CI

on:
  push:
    branches: [ main, master ]
  pull_request:

jobs:
  build:
    name: Build ${{ matrix.target }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        target: [ F072, F303 ]

    env:
      TARGET: ${{ matrix.target }}
      APTPACKAGES: gcc-arm-none-eabi libnewlib-arm-none-eabi dfu-util ccache python3
      CCACHEDIR: .ccache
      CCACHEMAXSIZE: 500M
      OSNAME: ubuntu-latest
      APT_USER_CACHE: ${{ github.workspace }}/.apt
      APT_USER_ARCHIVES: ${{ github.workspace }}/.apt/archives
      APT_USER_LISTS: ${{ github.workspace }}/.apt/lists

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      # Кешируем ТОЛЬКО пользовательские каталоги .apt/*
      - name: Restore APT user cache
        id: apt-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            .apt/archives
            .apt/lists
          key: apt-${{ env.OSNAME }}-${{ env.APTPACKAGES }}
          restore-keys: |
            apt-${{ env.OSNAME }}-

      - name: Prime APT from user cache
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$APT_USER_ARCHIVES/partial" "$APT_USER_LISTS/partial"
          # Подготовим системные каталоги
          sudo mkdir -p /var/cache/apt/archives /var/lib/apt/lists
          # Скопируем индексы и .deb из пользовательского кеша в системные каталоги (без lock/partial)
          if [ -d "$APT_USER_LISTS" ]; then
            sudo rsync -a --delete --exclude 'lock' --exclude 'partial' "$APT_USER_LISTS/" /var/lib/apt/lists/
          fi
          if [ -d "$APT_USER_ARCHIVES" ]; then
            sudo rsync -a --exclude 'lock' --exclude 'partial' "$APT_USER_ARCHIVES/" /var/cache/apt/archives/
          fi

      - name: Install toolchain and utils
        shell: bash
        run: |
          set -euo pipefail
          # Направляем apt использовать пользовательские каталоги для скачивания и списков,
          # но фактическая установка идёт в систему (sudo).
          sudo apt-get -o Dir::Cache::archives="$APT_USER_ARCHIVES" \
                       -o Dir::State::lists="$APT_USER_LISTS" \
                       -o Acquire::Retries=3 update
          sudo apt-get -y --no-install-recommends \
                       -o Dir::Cache::archives="$APT_USER_ARCHIVES" \
                       -o Dir::State::lists="$APT_USER_LISTS" \
                       install $APTPACKAGES
          arm-none-eabi-gcc --version || true
          ccache --version || true

      - name: Persist APT user cache back
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$APT_USER_ARCHIVES" "$APT_USER_LISTS"
          # Обновим пользовательский кеш из системных каталогов без lock/partial
          sudo rsync -a --delete --exclude 'lock' --exclude 'partial' /var/lib/apt/lists/ "$APT_USER_LISTS/"
          sudo rsync -a --exclude 'lock' --exclude 'partial' /var/cache/apt/archives/ "$APT_USER_ARCHIVES/"
          # Нормализуем владельца, чтобы actions/cache мог читать
          sudo chown -R "$(id -u):$(id -g)" "$APT_USER_CACHE"

      - name: Save APT user cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: |
            .apt/archives
            .apt/lists
          key: apt-${{ env.OSNAME }}-${{ env.APTPACKAGES }}

      - name: Enable ccache
        shell: bash
        run: |
          {
            echo "CC=ccache arm-none-eabi-gcc"
            echo "LD=ccache arm-none-eabi-ld"
            echo "AR=ccache arm-none-eabi-ar"
            echo "NM=ccache arm-none-eabi-nm"
            echo "OBJCOPY=arm-none-eabi-objcopy"
            echo "OBJDUMP=arm-none-eabi-objdump"
            echo "STRIP=arm-none-eabi-strip"
          } >> "$GITHUB_ENV"

      - name: Prepare cache dirs
        shell: bash
        run: |
          mkdir -p "$CCACHEDIR"
          mkdir -p build

      - name: Detect ARM GCC version
        id: gccver
        shell: bash
        run: |
          set -euo pipefail
          ver="$(arm-none-eabi-gcc -dumpversion || echo unknown)"
          echo "ver=$ver" >> "$GITHUB_OUTPUT"
          echo "ARM_GCC_VER=$ver" >> "$GITHUB_ENV"

      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHEDIR }}
          key: ccache-${{ env.OSNAME }}-${{ matrix.target }}-${{ steps.gccver.outputs.ver }}-${{ hashFiles('**/*.ch','**/*.ld','Makefile','tools/**','boards/**','include/**','src/**') }}
          restore-keys: |
            ccache-${{ env.OSNAME }}-${{ matrix.target }}-${{ steps.gccver.outputs.ver }}-
            ccache-${{ env.OSNAME }}-${{ matrix.target }}-
            ccache-${{ env.OSNAME }}-

      - name: Configure ccache
        shell: bash
        run: |
          ccache --set-config=cache_dir="$CCACHEDIR"
          ccache --set-config=max_size="$CCACHEMAXSIZE"
          ccache --set-config=compression=true
          ccache -z || true

      - name: Cache build directory
        uses: actions/cache@v4
        with:
          path: build
          key: build-${{ env.OSNAME }}-${{ matrix.target }}-${{ steps.gccver.outputs.ver }}-${{ hashFiles('Makefile','config/**','boards/**','include/**','src/**','tools/**') }}
          restore-keys: |
            build-${{ env.OSNAME }}-${{ matrix.target }}-${{ steps.gccver.outputs.ver }}-
            build-${{ env.OSNAME }}-${{ matrix.target }}-
            build-${{ env.OSNAME }}-

      - name: Build firmware
        env:
          TARGET: ${{ matrix.target }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${CLEAN-0}" = "1" ]; then
            make clean
          fi
          make -j"$(nproc)"
          ccache -s || true

      - name: Determine project name
        id: project
        shell: bash
        run: |
          if [ "${{ matrix.target }}" = "F303" ]; then
            echo "name=H4" >> "$GITHUB_OUTPUT"
            echo "dfusepreset=stm32f303xc" >> "$GITHUB_OUTPUT"
          else
            echo "name=H" >> "$GITHUB_OUTPUT"
            echo "dfusepreset=stm32f072xb" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate DFU if script exists
        shell: bash
        run: |
          set -euo pipefail
          proj="${{ steps.project.outputs.name }}"
          if [ -f tools/makedfu.py ]; then
            python3 tools/makedfu.py "build/${proj}.bin" "build/${proj}.dfu" --preset-target "${{ steps.project.outputs.dfusepreset }}" --device-id 0x0000
            if command -v dfu-suffix >/dev/null 2>&1; then
              dfu-suffix --check "build/${proj}.dfu" || true
            fi
          else
            echo "tools/makedfu.py not found, skipping DFU generation"
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: NanoVNA-X-${{ matrix.target }}
          if-no-files-found: error
          path: |
            build/${{ steps.project.outputs.name }}.bin
            build/${{ steps.project.outputs.name }}.hex
            build/${{ steps.project.outputs.name }}.dfu

      - name: Save ccache (final)
        if: always()
        uses: actions/cache/save@v4
        with:
          path: ${{ env.CCACHEDIR }}
          key: ccache-${{ env.OSNAME }}-${{ matrix.target }}-${{ steps.gccver.outputs.ver }}-${{ hashFiles('**/*.ch','**/*.ld','Makefile','tools/**','boards/**','include/**','src/**') }}
